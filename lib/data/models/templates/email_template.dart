// lib/models/email_template.dart

import 'package:hive/hive.dart';
import 'package:uuid/uuid.dart';

part '../../generated/email_template.g.dart';

@HiveType(typeId: 26) // Different typeId from message templates
class EmailTemplate extends HiveObject {
  @HiveField(0)
  final String id;

  @HiveField(1)
  final String templateName;

  @HiveField(2)
  final String description;

  @HiveField(3)
  final String category;

  @HiveField(4)
  final String subject;

  @HiveField(5)
  final String emailContent;

  @HiveField(6)
  final List<String> placeholders;

  @HiveField(7)
  final bool isActive;

  @HiveField(8)
  final int sortOrder;

  @HiveField(9)
  final DateTime createdAt;

  @HiveField(10)
  final DateTime updatedAt;

  @HiveField(11)
  final bool isHtml;

  @HiveField(12)
  String? userCategoryKey;


  EmailTemplate({
    String? id,
    required this.templateName,
    required this.description,
    required this.category,
    required this.subject,
    required this.emailContent,
    List<String>? placeholders,
    this.isActive = true,
    this.sortOrder = 0,
    DateTime? createdAt,
    DateTime? updatedAt,
    this.isHtml = false,
    this.userCategoryKey, // <<< ADDED THIS LINE
  }) :
        id = id ?? const Uuid().v4(),
        placeholders = placeholders ?? [],
        createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now();

  // Create a copy with modified fields
  EmailTemplate copyWith({
    String? templateName,
    String? description,
    String? category,
    String? subject,
    String? emailContent,
    List<String>? placeholders,
    bool? isActive,
    int? sortOrder,
    DateTime? updatedAt,
    bool? isHtml,
    String? userCategoryKey, // <<< ADDED THIS LINE
  }) {
    return EmailTemplate(
      id: id, // ID should not change on copyWith
      templateName: templateName ?? this.templateName,
      description: description ?? this.description,
      category: category ?? this.category,
      subject: subject ?? this.subject,
      emailContent: emailContent ?? this.emailContent,
      placeholders: placeholders ?? List.from(this.placeholders),
      isActive: isActive ?? this.isActive,
      sortOrder: sortOrder ?? this.sortOrder,
      createdAt: createdAt, // Keep original creation date
      updatedAt: updatedAt ?? DateTime.now(),
      isHtml: isHtml ?? this.isHtml,
      userCategoryKey: userCategoryKey ?? this.userCategoryKey, // <<< ADDED THIS LINE
    );
  }

  EmailTemplate clone() { // Added if not present, or modified
    return EmailTemplate(
      // id is regenerated by default constructor if null, or pass this.id if you want to keep it
      templateName: '$templateName (Copy)',
      description: description,
      category: category, // Old category
      subject: subject,
      emailContent: emailContent,
      placeholders: List.from(placeholders),
      isActive: isActive,
      sortOrder: sortOrder,
      createdAt: DateTime.now(), // New creation time for a clone
      updatedAt: DateTime.now(),
      isHtml: isHtml,
      userCategoryKey: userCategoryKey, // <<< ADDED THIS LINE
    );
  }

  // Extract placeholders from both subject and content
  static List<String> extractPlaceholders(String text) {
    final RegExp placeholderRegex = RegExp(r'\{([^}]+)\}');
    final matches = placeholderRegex.allMatches(text);
    return matches.map((match) => match.group(1)!).toSet().toList();
  }

  // Extract placeholders from both subject and email content
  static List<String> extractAllPlaceholders(String subject, String content) {
    final subjectPlaceholders = extractPlaceholders(subject);
    final contentPlaceholders = extractPlaceholders(content);
    return {...subjectPlaceholders, ...contentPlaceholders}.toList();
  }

  // Replace placeholders with actual values in both subject and content
  Map<String, String> generateEmail(Map<String, String> values) {
    String processedSubject = subject;
    String processedContent = emailContent;

    for (final placeholder in placeholders) {
      final value = values[placeholder] ?? '{$placeholder}';
      processedSubject = processedSubject.replaceAll('{$placeholder}', value);
      processedContent = processedContent.replaceAll('{$placeholder}', value);
    }

    return {
      'subject': processedSubject,
      'content': processedContent,
    };
  }

  // ============= APP DATA INTEGRATION (Same as Message Templates) =============

  /// Get all available app data field types (same as message templates)
  static List<String> getAllAppDataFieldTypes(List<dynamic> products, List<dynamic> customFields) {
    final allFields = <String>[];

    // Core customer fields
    allFields.addAll([
      'customerName',
      'customerFirstName',
      'customerLastName',
      'customerStreetAddress',
      'customerCity',
      'customerState',
      'customerZipCode',
      'customerFullAddress',
      'customerPhone',
      'customerEmail',
    ]);

    // Core company fields
    allFields.addAll([
      'companyName',
      'companyAddress',
      'companyPhone',
      'companyEmail',
    ]);

    // Quote information
    allFields.addAll([
      'quoteNumber',
      'quoteDate',
      'validUntil',
      'quoteStatus',
      'todaysDate',
      'notes',
      'terms',
      'upgradeQuoteText',
    ]);

    // Quote levels
    for (int i = 1; i <= 3; i++) {
      allFields.addAll([
        'level${i}Name',
        'level${i}Subtotal',
        'level${i}Tax',
        'level${i}TotalWithTax',
      ]);
    }

    // DYNAMIC PRODUCTS - from actual product list
    for (final product in products) {
      final String productName;

      if (product is Map<String, dynamic>) {
        productName = product['name'] as String? ?? 'Unknown Product';
      } else {
        productName = product.name as String? ?? 'Unknown Product';
      }

      final safeProductName = productName.replaceAll(RegExp(r'[^\w]'), '');
      allFields.addAll([
        'product_${safeProductName}_quantity',
        'product_${safeProductName}_unitPrice',
        'product_${safeProductName}_total',
      ]);
    }

    // Overall calculations
    allFields.addAll([
      'subtotal',
      'discount',
      'taxRate',
      'taxAmount',
      'grandTotal',
    ]);

    // Custom app data fields
    for (final field in customFields) {
      final String fieldName;
      if (field is Map<String, dynamic>) {
        fieldName = field['fieldName'] as String? ?? '';
      } else {
        fieldName = field.fieldName as String? ?? '';
      }
      if (fieldName.isNotEmpty && !allFields.contains(fieldName)) {
        allFields.add(fieldName);
      }
    }

    return allFields;
  }

  /// Get categorized field types for organized UI (same structure as message templates)
  static Map<String, List<String>> getCategorizedAppDataFieldTypes(List<dynamic> products, List<dynamic> customFields) {
    final categories = <String, List<String>>{};

    categories['Customer Information'] = [
      'customerName',
      'customerFirstName',
      'customerLastName',
      'customerStreetAddress',
      'customerCity',
      'customerState',
      'customerZipCode',
      'customerFullAddress',
      'customerPhone',
      'customerEmail',
    ];

    categories['Company Information'] = [
      'companyName',
      'companyAddress',
      'companyPhone',
      'companyEmail',
    ];

    categories['Quote Information'] = [
      'quoteNumber',
      'quoteDate',
      'validUntil',
      'quoteStatus',
      'todaysDate',
      'notes',
      'terms',
      'upgradeQuoteText',
    ];

    categories['Quote Levels'] = [
      'level1Name', 'level1Subtotal', 'level1Tax', 'level1TotalWithTax',
      'level2Name', 'level2Subtotal', 'level2Tax', 'level2TotalWithTax',
      'level3Name', 'level3Subtotal', 'level3Tax', 'level3TotalWithTax',
    ];

    // DYNAMIC PRODUCTS - same as message templates
    if (products.isNotEmpty) {
      final productFields = <String>[];

      for (final product in products.take(10)) { // Limit to first 10 products
        final String productName;

        if (product is Map<String, dynamic>) {
          productName = product['name'] as String? ?? 'Unknown Product';
        } else {
          productName = product.name as String? ?? 'Unknown Product';
        }

        // Create dynamic field names based on actual product
        final safeProductName = productName.replaceAll(RegExp(r'[^\w]'), '');
        productFields.addAll([
          'product_${safeProductName}_quantity',
          'product_${safeProductName}_unitPrice',
          'product_${safeProductName}_total',
        ]);
      }

      if (productFields.isNotEmpty) {
        categories['Available Products'] = productFields;
      }
    }

    categories['Calculations & Totals'] = [
      'subtotal',
      'discount',
      'taxRate',
      'taxAmount',
      'grandTotal',
    ];

    // Custom fields by category
    final customFieldsByCategory = <String, List<String>>{};
    for (final field in customFields) {
      final String fieldName;
      final String category;

      if (field is Map<String, dynamic>) {
        fieldName = field['fieldName'] as String? ?? '';
        category = field['category'] as String? ?? 'Fields';
      } else {
        fieldName = field.fieldName as String? ?? '';
        category = field.category as String? ?? 'Fields';
      }

      if (fieldName.isNotEmpty) {
        customFieldsByCategory.putIfAbsent(category, () => []).add(fieldName);
      }
    }

    categories.addAll(customFieldsByCategory);

    return categories;
  }

  /// Get display name for field (same as message templates)
  static String getFieldDisplayName(String fieldType, [List<dynamic>? customFields]) {
    // Check custom fields first
    if (customFields != null) {
      for (final field in customFields) {
        final String fieldName;
        final String displayName;

        if (field is Map<String, dynamic>) {
          fieldName = field['fieldName'] as String? ?? '';
          displayName = field['displayName'] as String? ?? fieldName;
        } else {
          fieldName = field.fieldName as String? ?? '';
          displayName = field.displayName as String? ?? fieldName;
        }

        if (fieldName == fieldType) {
          return displayName;
        }
      }
    }

    // Handle dynamic product fields
    if (fieldType.startsWith('product_') && fieldType.contains('_')) {
      final parts = fieldType.split('_');
      if (parts.length >= 3) {
        final productName = parts[1];
        final fieldSuffix = parts[2];

        switch (fieldSuffix) {
          case 'quantity':
            return '$productName - Quantity';
          case 'unitPrice':
            return '$productName - Unit Price';
          case 'total':
            return '$productName - Total Price';
          default:
            return '$productName - ${fieldSuffix.toUpperCase()}';
        }
      }
    }

    // Standard field display names
    const displayNames = {
      'customerName': 'Customer Name',
      'customerFirstName': 'Customer First Name',
      'customerLastName': 'Customer Last Name',
      'customerStreetAddress': 'Customer Street Address',
      'customerCity': 'Customer City',
      'customerState': 'Customer State',
      'customerZipCode': 'Customer Zip Code',
      'customerFullAddress': 'Customer Full Address',
      'customerPhone': 'Customer Phone',
      'customerEmail': 'Customer Email',
      'companyName': 'Company Name',
      'companyAddress': 'Company Address',
      'companyPhone': 'Company Phone',
      'companyEmail': 'Company Email',
      'quoteNumber': 'Quote Number',
      'quoteDate': 'Quote Date',
      'validUntil': 'Valid Until',
      'quoteStatus': 'Quote Status',
      'todaysDate': 'Today\'s Date',
      'subtotal': 'Subtotal',
      'taxRate': 'Tax Rate',
      'taxAmount': 'Tax Amount',
      'grandTotal': 'Grand Total',
      'notes': 'Project Notes',
      'terms': 'Terms & Conditions',
      'upgradeQuoteText': 'Upgrade Quote Text',
      'level1Name': 'Level 1 Name',
      'level1Subtotal': 'Level 1 Subtotal',
      'level1Tax': 'Level 1 Tax',
      'level1TotalWithTax': 'Level 1 Total with Tax',
      'level2Name': 'Level 2 Name',
      'level2Subtotal': 'Level 2 Subtotal',
      'level2Tax': 'Level 2 Tax',
      'level2TotalWithTax': 'Level 2 Total with Tax',
      'level3Name': 'Level 3 Name',
      'level3Subtotal': 'Level 3 Subtotal',
      'level3Tax': 'Level 3 Tax',
      'level3TotalWithTax': 'Level 3 Total with Tax',
    };

    return displayNames[fieldType] ?? fieldType.replaceAll('_', ' ').toUpperCase();
  }

  // Convert to JSON for storage
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'templateName': templateName,
      'description': description,
      'category': category,
      'subject': subject,
      'emailContent': emailContent,
      'placeholders': placeholders,
      'isActive': isActive,
      'sortOrder': sortOrder,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
      'isHtml': isHtml,
      'userCategoryKey': userCategoryKey, // <<< ADDED THIS LINE
    };
  }

  // Create from JSON
  factory EmailTemplate.fromJson(Map<String, dynamic> json) {
    return EmailTemplate(
      id: json['id'] as String?,
      templateName: json['templateName'] as String,
      description: json['description'] as String? ?? '',
      category: json['category'] as String,
      subject: json['subject'] as String,
      emailContent: json['emailContent'] as String,
      placeholders: List<String>.from(json['placeholders'] as List? ?? []),
      isActive: json['isActive'] as bool? ?? true,
      sortOrder: json['sortOrder'] as int? ?? 0,
      createdAt: json['createdAt'] != null ? DateTime.parse(json['createdAt'] as String) : DateTime.now(),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt'] as String) : DateTime.now(),
      isHtml: json['isHtml'] as bool? ?? false,
      userCategoryKey: json['userCategoryKey'] as String?, // <<< ADDED THIS LINE
    );
  }

  @override
  String toString() {
    return 'EmailTemplate(id: $id, name: $templateName, category: $category, userCategoryKey: $userCategoryKey)';
  }


  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is EmailTemplate && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}