// lib/models/message_template.dart (HIVE ANNOTATIONS REMOVED)

import 'package:uuid/uuid.dart';

class MessageTemplate {
  final String id;
  final String templateName;
  final String description;
  final String category;
  final String messageContent;
  final List<String> placeholders;
  final bool isActive;
  final int sortOrder;
  final DateTime createdAt;
  final DateTime updatedAt;
  String? userCategoryKey;

  MessageTemplate({
    String? id,
    required this.templateName,
    required this.description,
    required this.category,
    required this.messageContent,
    List<String>? placeholders,
    this.isActive = true,
    this.sortOrder = 0,
    DateTime? createdAt,
    DateTime? updatedAt,
    this.userCategoryKey,
  }) :
        id = id ?? const Uuid().v4(),
        placeholders = placeholders ?? [],
        createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now();

  // Create a copy with modified fields
  MessageTemplate copyWith({
    String? templateName,
    String? description,
    String? category,
    String? messageContent,
    List<String>? placeholders,
    bool? isActive,
    int? sortOrder,
    DateTime? updatedAt,
    String? userCategoryKey,
  }) {
    return MessageTemplate(
      id: id,
      templateName: templateName ?? this.templateName,
      description: description ?? this.description,
      category: category ?? this.category,
      messageContent: messageContent ?? this.messageContent,
      placeholders: placeholders ?? List.from(this.placeholders),
      isActive: isActive ?? this.isActive,
      sortOrder: sortOrder ?? this.sortOrder,
      createdAt: createdAt,
      updatedAt: updatedAt ?? DateTime.now(),
      userCategoryKey: userCategoryKey ?? this.userCategoryKey,
    );
  }

  // Create a duplicate template
  MessageTemplate clone() {
    return MessageTemplate(
      // id is regenerated by default constructor if null, or pass this.id if you want to keep it
      templateName: '$templateName (Copy)',
      description: description,
      category: category,
      messageContent: messageContent,
      placeholders: List.from(placeholders),
      isActive: isActive,
      sortOrder: sortOrder,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      userCategoryKey: userCategoryKey, // <<< ADDED THIS LINE
    );
  }

  // Convert to JSON for storage
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'templateName': templateName,
      'description': description,
      'category': category,
      'messageContent': messageContent,
      'placeholders': placeholders,
      'isActive': isActive,
      'sortOrder': sortOrder,
      'createdAt': createdAt.toIso8601String(),
      'updatedAt': updatedAt.toIso8601String(),
      'userCategoryKey': userCategoryKey,
    };
  }

  // Create from JSON
  factory MessageTemplate.fromJson(Map<String, dynamic> json) {
    return MessageTemplate(
      id: json['id'] as String?,
      templateName: json['templateName'] as String,
      description: json['description'] as String? ?? '',
      category: json['category'] as String,
      messageContent: json['messageContent'] as String,
      placeholders: List<String>.from(json['placeholders'] as List? ?? []),
      isActive: json['isActive'] as bool? ?? true,
      sortOrder: json['sortOrder'] as int? ?? 0,
      createdAt: json['createdAt'] != null ? DateTime.parse(json['createdAt'] as String) : DateTime.now(),
      updatedAt: json['updatedAt'] != null ? DateTime.parse(json['updatedAt'] as String) : DateTime.now(),
      userCategoryKey: json['userCategoryKey'] as String?, // <<< ADDED THIS LINE
    );
  }

  // Extract placeholders from message content
  static List<String> extractPlaceholders(String content) {
    final RegExp placeholderRegex = RegExp(r'\{([^}]+)\}');
    final matches = placeholderRegex.allMatches(content);
    return matches.map((match) => match.group(1)!).toSet().toList();
  }

  // Replace placeholders with actual values
  String generateMessage(Map<String, String> values) {
    String result = messageContent;
    for (final placeholder in placeholders) {
      final value = values[placeholder] ?? '{$placeholder}';
      result = result.replaceAll('{$placeholder}', value);
    }
    return result;
  }

  // ============= NEW: APP DATA INTEGRATION =============

  /// Get all available app data field types (same as PDF templates)
  /// Get all available app data field types (same as PDF templates)
  /// Get all available app data field types (same as PDF templates)
  static List<String> getAllAppDataFieldTypes(List<dynamic> products, List<dynamic> customFields) {
    final allFields = <String>[];

    // Core customer fields
    allFields.addAll([
      'customerName',
      'customerFirstName',
      'customerLastName',
      'customerStreetAddress',
      'customerCity',
      'customerState',
      'customerZipCode',
      'customerFullAddress',
      'customerPhone',
      'customerEmail',
    ]);

    // Core company fields
    allFields.addAll([
      'companyName',
      'companyAddress',
      'companyPhone',
      'companyEmail',
    ]);

    // Quote information
    allFields.addAll([
      'quoteNumber',
      'quoteDate',
      'validUntil',
      'quoteStatus',
      'todaysDate',
      'notes',
      'terms',
      'upgradeQuoteText',
    ]);

    // Quote levels
    for (int i = 1; i <= 3; i++) {
      allFields.addAll([
        'level${i}Name',
        'level${i}Subtotal',
        'level${i}Tax',
        'level${i}TotalWithTax',
      ]);
    }

    // DYNAMIC PRODUCTS - from actual product list
    for (final product in products) {
      final String productName;

      if (product is Map<String, dynamic>) {
        productName = product['name'] as String? ?? 'Unknown Product';
      } else {
        productName = product.name as String? ?? 'Unknown Product';
      }

      final safeProductName = productName.replaceAll(RegExp(r'[^\w]'), '');
      allFields.addAll([
        'product_${safeProductName}_quantity',
        'product_${safeProductName}_unitPrice',
        'product_${safeProductName}_total',
      ]);
    }

    // Overall calculations
    allFields.addAll([
      'subtotal',
      'discount',
      'taxRate',
      'taxAmount',
      'grandTotal',
    ]);

    // Custom app data fields
    for (final field in customFields) {
      final String fieldName;
      if (field is Map<String, dynamic>) {
        fieldName = field['fieldName'] as String? ?? '';
      } else {
        fieldName = field.fieldName as String? ?? '';
      }
      if (fieldName.isNotEmpty && !allFields.contains(fieldName)) {
        allFields.add(fieldName);
      }
    }

    return allFields;
  }

  /// Get categorized field types for organized UI (same structure as PDF templates)
  /// Get categorized field types for organized UI (same structure as PDF templates)
  /// Get categorized field types for organized UI (same structure as PDF templates)
  static Map<String, List<String>> getCategorizedAppDataFieldTypes(List<dynamic> products, List<dynamic> customFields) {
    final categories = <String, List<String>>{};

    categories['Customer Information'] = [
      'customerName',
      'customerFirstName',
      'customerLastName',
      'customerStreetAddress',
      'customerCity',
      'customerState',
      'customerZipCode',
      'customerFullAddress',
      'customerPhone',
      'customerEmail',
    ];

    categories['Company Information'] = [
      'companyName',
      'companyAddress',
      'companyPhone',
      'companyEmail',
    ];

    categories['Quote Information'] = [
      'quoteNumber',
      'quoteDate',
      'validUntil',
      'quoteStatus',
      'todaysDate',
      'notes',
      'terms',
      'upgradeQuoteText',
    ];

    categories['Quote Levels'] = [
      'level1Name', 'level1Subtotal', 'level1Tax', 'level1TotalWithTax',
      'level2Name', 'level2Subtotal', 'level2Tax', 'level2TotalWithTax',
      'level3Name', 'level3Subtotal', 'level3Tax', 'level3TotalWithTax',
    ];

    // DYNAMIC PRODUCTS - same as PDF templates
    if (products.isNotEmpty) {
      final productFields = <String>[];

      for (final product in products.take(10)) { // Limit to first 10 products
        final String productName;

        if (product is Map<String, dynamic>) {
          productName = product['name'] as String? ?? 'Unknown Product';
        } else {
          productName = product.name as String? ?? 'Unknown Product';
        }

        // Create dynamic field names based on actual product
        final safeProductName = productName.replaceAll(RegExp(r'[^\w]'), '');
        productFields.addAll([
          'product_${safeProductName}_quantity',
          'product_${safeProductName}_unitPrice',
          'product_${safeProductName}_total',
        ]);
      }

      if (productFields.isNotEmpty) {
        categories['Available Products'] = productFields;
      }
    }

    // Generic product fields


    categories['Calculations & Totals'] = [
      'subtotal',
      'discount',
      'taxRate',
      'taxAmount',
      'grandTotal',
    ];


    // Custom fields by category
    final customFieldsByCategory = <String, List<String>>{};
    for (final field in customFields) {
      final String fieldName;
      final String category;

      if (field is Map<String, dynamic>) {
        fieldName = field['fieldName'] as String? ?? '';
        category = field['category'] as String? ?? 'Fields';
      } else {
        fieldName = field.fieldName as String? ?? '';
        category = field.category as String? ?? 'Fields';
      }

      if (fieldName.isNotEmpty) {
        customFieldsByCategory.putIfAbsent(category, () => []).add(fieldName);
      }
    }

    categories.addAll(customFieldsByCategory);

    return categories;
  }

  /// Get display name for field (same as PDF templates)
  /// Get display name for field (same as PDF templates)
  static String getFieldDisplayName(String fieldType, [List<dynamic>? customFields]) {
    // Check custom fields first
    if (customFields != null) {
      for (final field in customFields) {
        final String fieldName;
        final String displayName;

        if (field is Map<String, dynamic>) {
          fieldName = field['fieldName'] as String? ?? '';
          displayName = field['displayName'] as String? ?? fieldName;
        } else {
          fieldName = field.fieldName as String? ?? '';
          displayName = field.displayName as String? ?? fieldName;
        }

        if (fieldName == fieldType) {
          return displayName;
        }
      }
    }

    // Handle dynamic product fields
    if (fieldType.startsWith('product_') && fieldType.contains('_')) {
      final parts = fieldType.split('_');
      if (parts.length >= 3) {
        final productName = parts[1];
        final fieldSuffix = parts[2];

        switch (fieldSuffix) {
          case 'quantity':
            return '$productName - Quantity';
          case 'unitPrice':
            return '$productName - Unit Price';
          case 'total':
            return '$productName - Total Price';
          default:
            return '$productName - ${fieldSuffix.toUpperCase()}';
        }
      }
    }

    // Standard field display names
    const displayNames = {
      'customerName': 'Customer Name',
      'customerFirstName': 'Customer First Name',
      'customerLastName': 'Customer Last Name',
      'customerStreetAddress': 'Customer Street Address',
      'customerCity': 'Customer City',
      'customerState': 'Customer State',
      'customerZipCode': 'Customer Zip Code',
      'customerFullAddress': 'Customer Full Address',
      'customerPhone': 'Customer Phone',
      'customerEmail': 'Customer Email',
      'companyName': 'Company Name',
      'companyAddress': 'Company Address',
      'companyPhone': 'Company Phone',
      'companyEmail': 'Company Email',
      'quoteNumber': 'Quote Number',
      'quoteDate': 'Quote Date',
      'validUntil': 'Valid Until',
      'quoteStatus': 'Quote Status',
      'todaysDate': 'Today\'s Date',
      'subtotal': 'Subtotal',
      'taxRate': 'Tax Rate',
      'taxAmount': 'Tax Amount',
      'grandTotal': 'Grand Total',
      'notes': 'Project Notes',
      'terms': 'Terms & Conditions',
      'upgradeQuoteText': 'Upgrade Quote Text',
      'level1Name': 'Level 1 Name',
      'level1Subtotal': 'Level 1 Subtotal',
      'level1Tax': 'Level 1 Tax',
      'level1TotalWithTax': 'Level 1 Total with Tax',
      'level2Name': 'Level 2 Name',
      'level2Subtotal': 'Level 2 Subtotal',
      'level2Tax': 'Level 2 Tax',
      'level2TotalWithTax': 'Level 2 Total with Tax',
      'level3Name': 'Level 3 Name',
      'level3Subtotal': 'Level 3 Subtotal',
      'level3Tax': 'Level 3 Tax',
      'level3TotalWithTax': 'Level 3 Total with Tax',
    };

    return displayNames[fieldType] ?? fieldType.replaceAll('_', ' ').toUpperCase();
  }

// Legacy method for backward compatibility
  static List<String> getAvailablePlaceholders() {
    // Return basic list for backward compatibility
    return [
      'customerName',
      'customerPhone',
      'customerEmail',
      'companyName',
      'companyPhone',
      'quoteNumber',
      'quoteDate',
      'todaysDate',
    ];
  }

  // Get placeholder descriptions for UI
  static Map<String, String> getPlaceholderDescriptions() {
    return {
      'customer_name': 'Full customer name',
      'customer_first_name': 'Customer first name',
      'customer_last_name': 'Customer last name',
      'customer_phone': 'Customer phone number',
      'customer_email': 'Customer email address',
      'customer_address': 'Customer home address',
      'project_address': 'Job site address',
      'company_name': 'Your company name',
      'company_phone': 'Your company phone',
      'company_email': 'Your company email',
      'representative_name': 'Sales representative name',
      'quote_number': 'Quote reference number',
      'quote_total': 'Total quote amount',
      'appointment_date': 'Scheduled appointment date',
      'appointment_time': 'Scheduled appointment time',
      'job_status': 'Current job status',
      'payment_amount': 'Payment amount due',
      'payment_due_date': 'Payment due date',
      'current_date': 'Today\'s date',
      'current_time': 'Current time',
    };
  }

  @override
  String toString() {
    return 'MessageTemplate(id: $id, name: $templateName, category: $category, userCategoryKey: $userCategoryKey)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is MessageTemplate && other.id == id;
  }

  @override
  int get hashCode => id.hashCode;
}